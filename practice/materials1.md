
# Практичне заняття 1. Знайомство з терміналом лінукс

Рекомендовані ресурси:
- https://vnav.mit.edu/labs/lab1/
- [Linux System Programming](https://doc.lagout.org/programmation/unix/Linux%20System%20Programming%20Talking%20Directly%20to%20the%20Kernel%20and%20C%20Library.pdf)
- https://www.youtube.com/watch?v=uCqOgWR0g2o
- https://www.kernel.org/doc/html/latest/
- https://www.youtube.com/watch?v=3-nuMiXqZxE


Впродовж курсу вам необхідно буде вміти працювати з лінукс-машиною, користуючись суто
терміналом. Тут зібрано основні команди, які вам можуть знадобитись для цього, а також
ключові слова, які варто буде гуглити.


## Допомога

### `man <command>` (Manual)
Скоріш за все, ваша система матиме вбудований переглядач документації `man`. З мінусів, тексти там доволі складні для
розуміння.

### `tldr <command>` (Too Long Didn't Read)

Коротка вижимка з документації + основні приклади використання.
Але треба встановлювати, за замовчуванням її нема: https://github.com/tldr-pages/tldr/wiki/Clients. 


## Навігація

В Unix системах вся файлова система організована ієрархічно у вигляді дерева. Головним є
т.зв. **корінь**, який позначається як `/`. Всі інші папки мусять мати корінь як префікс (з деякими винятками).

Приклади:
```shell
/
/boot         # папка з файлами, які потрібні для завантаження системи (чіпаєм тільки /boot/firmware/config.txt)
/etc          # загально-системні конфіги (тут будем і ми зберігати наші конфіги)

/home         # місце, де зберігаються всі користувацькі налаштування
/home/root    # домашня директорія супер користувача `root` (тут нічо не робим)
/home/user    # домашня директорія користувача `user`, часто її позначають як ~/
              # (основне наше робоче місце, сюди ви попадаєте після ssh)

/lib          # всякі системні інклюди (тут нас цікавитиме /lib/systemd/system)
/usr/bin      # папка з загально-системними бінарниками (тут будем зберігати наші програми)
/usr/lib      # якісь інші інклюди, хз

/dev          # тут знаходиться вся периферія -- всі девайси, з якими якимсь чином треба спілкуватись
              # кожен девайс в лінуксі косить під файл, в цій папці якраз будуть всі такі файли і знаходитись

/media        # сюди монтуються всякі USB 
/mnt          # сюди монтуються всякі внутрішні і зовнішні диски


/tmp          # тимчасові файли (будем її використовувати, власне, для тимчасових файлів)
/var          # всякі кеші, не чіпаєм цю папку
```

Варто розуміти, що ʼієрархічна структураʼ не означає, що всі файли у вас зберігаються саме в такому вигляді
на диску. Більше того, `/` може бути на одному диску, а `/home`, наприклад, на іншому.


### `pwd` (Print Working Directory)
видає вам де ви зараз знаходитесь.
```
$ pwd
/home/pi/
```


### `cd <dir>` (~~see deez nuts~~ Change Directory)
перейти в директорію.

```shell

$ cd /     # перейти в корінь
$ pwd
/
$ cd ~/    # перейти в домашню директорію
$ pwd
/home/pi
$ cd -     # повернутись в попереднє місце
$ pwd
/
$ cd ~/Downloads
$ pwd
/home/pi/Downloads
$ cd ..    # перейти на рівень назад
$ pwd
/home/pi/
```

### `ls` (LiSt contents)
показує список файлів і папок в нинішній директорії. Аргумент `-a` дозволяє побачити приховані файли, а
`-l` виводить все розгорнутим списком. Часто в системі є ще скорочення `ll='ls -la'` i `l='ls'`.

```shell
$ ls
labworks  latex     LICENSE   practice  README.md venv

$ ls -la
drwxr-xr-x@ 11 davendiy  staff   352 Sep 11 23:17 .
drwxr-xr-x   6 davendiy  staff   192 Sep 11 14:29 ..
-rw-r--r--@  1 davendiy  staff  6148 Sep 11 23:17 .DS_Store
drwxr-xr-x@ 14 davendiy  staff   448 Sep 11 23:17 .git
-rw-r--r--@  1 davendiy  staff  3443 Mar 31 23:05 .gitignore
drwxr-xr-x   4 davendiy  staff   128 Sep 11 22:46 labworks
drwxr-xr-x   3 davendiy  staff    96 Sep  2 13:47 latex
-rw-r--r--@  1 davendiy  staff  1065 Mar 31 23:05 LICENSE
drwxr-xr-x   4 davendiy  staff   128 Sep 11 22:46 practice
-rw-r--r--   1 davendiy  staff  3441 Sep  4 19:51 README.md
drwxr-xr-x   8 davendiy  staff   256 Sep 11 15:28 venv
```

Перша незрозуміла колонка означає доступи і ownership кожного файлу. Приклад: `drwxr-xr-x` треба читати трійками `d rwx r-x r-x`
як файл/папка, доступи власника, доступи групи власника і доступи _інших_. `r` -- read, `w` -- write, `x` -- execute.
Отже, `drwxr-xr-x` означає, що це:
- `d` -- папка
- `rwx` -- власник має всі доступи
- `r-x` -- група має право тільки читати і виконувати
- `r-x` -- _інші_ мають право тільки читати і виконувати.

Тут власник -- це користувач, який створив файл. Він якраз вказаний в третій колонці (davendiy). 


### `find`
шукає файли з заданими параметрами (наприклад, по назві)
```shell
$ find . -name "*.md"
./labworks/lab1.md
./labworks/lab2.md
./README.md
./venv/lib/python3.13/site-packages/numpy/random/LICENSE.md
./practice/materials1.md
````


---

## Редагування файлової системи

### `mkdir <name>`  (Make Directory)
створити папку

```shell
$ mkdir test
$ ls
test 
```

### `touch <file>`
створити порожній файл АБО змінити дату останнього редагування/читання для існуючого файлу.

```shell
$ touch test.py
$ ls
test test.py
```

### `mv <src> <dest>` (MoVe)
перемісити файл/папку або перейменувати.

```shell
$ mv test.py test2.py   # перейменувати файл
$ ls
test test2.py
$ mv test2.py test/     # перемістити файл в папку test/
$ ls
test
$ cd test/
$ ls
test2.py
```


### `cp <src> <dest>` (CoPy)
аналогічно до `mv`, тільки копіює файл/папку. Щоб скопіювати папку, треба додати параметр `-r` (recursive).

### `rmdir <dir>` (ReMove Directory)
видалити порожню папку.

### `rm <file>` (ReMove)
видалити файл або папку (треба додати параметр `-r`).

---

Окрім звичайних файлів і директорій в лінуксі також дофіга різних понять, які роблять вид, що вони файли. Це все
завдяки підходу *Everything is a file*, за яким кожен зовнішній девайс (камера, модем, клавіатура, блютуз і тп)
створює псевдо-файл, в який можна писати і з якого можна читати. Таким чином забезпечується обмін інформацією з
девайсами.


Варто ще згадати існування `hard links` i `symbolic links` -- це, по суті, посилання на папки/файли. Вони нам дозволяють
робити коротші шляхи з одного місця в інший. Ми будемо використовувати саме `symbolic links`.

### `ln <src> <dest>` (LiNk)
створити посилання (`hard link` або `symbolic link`) на файл/папку

```shell
$ ln -s ../../assets/practice2/dataset-gps example_dataset   # створюєм посилання на папку, яка знаходиться десь інде
$ ls -la
total 32
drwxr-xr-x   5 davendiy  staff   160 Sep 11 23:50 .
drwxr-xr-x@ 11 davendiy  staff   352 Sep 11 23:17 ..
lrwxr-xr-x   1 davendiy  staff    34 Sep 11 23:50 example_dataset -> ../../assets/practice2/dataset-gps

$ cd example_dataset   # посилання для нас тупо не відрізняється від звичайної папки
$ pwd
/Users/.../visual-navigation-systems/vnav-knu2025/practice/example_dataset
$ cd -
$ pwd
/Users/davendiy/.../visual-navigation-systems/vnav-knu2025/practice

$ ln -s ../../assets/practice2/output.csv output.csv
$ ll
total 32
drwxr-xr-x   6 davendiy  staff   192 Sep 11 23:55 .
drwxr-xr-x@ 11 davendiy  staff   352 Sep 11 23:17 ..
lrwxr-xr-x   1 davendiy  staff    34 Sep 11 23:50 example_dataset -> ../../assets/practice2/dataset-gps
-rw-r--r--   1 davendiy  staff  8750 Sep 11 23:52 materials1.md
lrwxr-xr-x   1 davendiy  staff    33 Sep 11 23:55 output.csv -> ../../assets/practice2/output.csv

$ head output.csv   # посилання на файл теж виглядає тупо як звичайний файл
timestamp,TimeUS,DesRoll,Roll,DesPitch,Pitch,DesYaw,Yaw,ErrRP,ErrYaw,AEKF
176.48235600,176482356,0.0,7.07,0.0,0.13,57.8,54.42,0.0,0.0,3
176.58221000,176582210,0.0,7.07,0.0,0.13,60.8,54.43,0.0,0.0,3
176.68236700,176682367,0.0,7.07,0.0,0.13,63.8,54.44,0.0,0.0,3
176.78237800,176782378,0.0,7.07,0.0,0.13,66.8,54.45,0.0,0.0,3
176.88220000,176882200,0.0,7.07,0.0,0.13,69.8,54.46,0.0,0.0,3
176.98223500,176982235,0.0,7.07,0.0,0.13,72.8,54.47,0.0,0.0,3
177.08219200,177082192,0.0,7.07,0.0,0.13,75.8,54.48,0.0,0.0,3
177.18243400,177182434,0.0,7.07,0.0,0.13,78.8,54.49,0.0,0.0,3
177.28220400,177282204,0.0,7.07,0.0,0.13,81.8,54.5,0.0,0.0,3
```

---

## Читання і редагування файлів

### `cat`  (Concatenate And Print)
прочитати і вивести контент заданих файлів.

```shell
$ cat test.txt
hello world!

```

### `echo` 
вивести аргументи в stdout. Якщо просто її викликати, то вона буквально повторить за вами. Натомість можна
_перенаправити_ вивід програми в файл і таким чином швидко щось записати туди.

```shell

$ ls
$ echo "Hello world!" > test.txt    # > перенаправляє вивід і затирає файл
$ ls
test.txt
$ cat test.txt
Hello world!

$ echo "yo" >> test.txt             # >> перенаправляє вивід і записує в кінець файлу
$ cat test.txt
Hello world!
yo
```

### `vi` i `nano`

___Для тих, кому впадлу розбиратись, існує `nano` -- мінімалістичний редактор текстових файлів___. Є тільки невеличкий нюанс,
що виходити з нього треба через CTRL+X, а потім `y` або `n` щоб, відповідно, зберегти або ніт (знизу підказки є для цього,
але вони не інтуїтивні).

Якщо ж хочеться приколів, то є `vi` або його покращена (тм) версія `vim`. Перший точно є на будь-якому лінуксі, який би
ви не спробували, а от `vim` є не завжди. Для особливо вибагливих можна ще поставити `neovim` або `helix` наприклад.

Працювати з вімом відносно просто, якщо знаєте основні приколи:
- рухатись можна стрілочками, можете забити на `h` `j` `k` `l`
- по дефолту ви в `NORMAL` моді, який сприймає текст як команди. Щоб почати щось вводити, треба натицьнути `i` (`INSERT` mode).
Щоб перейти назад в `NORMAL` треба тицьнути `ESC`.
- можна швидше вертикально рухатись по файлу, якщо замість стрілочок користуваться `{` i `}` --
вони переходять до наступного порожнього рядка. Якщо ж файл без таких рядків (наприклад csv), то
краще `CTRL+U` (Up) i `CTRL+D` (Down). Останні, до речі, працюють в довільному термінальному редакторі (наприклад як
дивитесь `git diff`).
- по горизонталі можна швидше рухатись за допомогою `w` i `b`
- пошук ___(дуже корисно)___ активується натиснувши `/` і далі вводите слово, яке шукаєте 
- щоб вийти з віма треба перейти в `NORMAL` режим і ввести `:q`. Щоб вийти і відкинути всі зміни `:q!`. Щоб зберегти зміни
`:wq`


Все інше можете дивитись в `:tutor` або, наприклад, погратись в браузерну гру https://vim-adventures.com/.


___Зауваження___: `helix` прикольний, але в нього свої комбінації. На разберях хелікса не буде, тому або доведеться
знати і вім, і хелікс, або ж поставте собі вімовські комбінації через https://github.com/LGUG2Z/helix-vim.

---

Про структуру Unix файлової системи написано в інтернетах багато, ось кілька прикладів:
- https://tecadmin.net/linux-file-system/
- https://www.youtube.com/watch?v=uCqOgWR0g2o
- [Linux System Programming, p.10](https://doc.lagout.org/programmation/unix/Linux%20System%20Programming%20Talking%20Directly%20to%20the%20Kernel%20and%20C%20Library.pdf)


---

## Скрипти

Впродовж роботи вам часто доведеться викликати багато термінальних команд, щоб щось налаштувати. Хорошою звичкою буде
під час цього всього робити собі якийсь конспект з основними командами або мати папочку з bash-скриптами.

bash скрипти, по суті, є просто термінальними командами в файліку з розширенням `.sh`. Ба більше, в лінуксі взагалі
на розширення забити можна, головне щоб файл був виконувальним.

Більше інфи по баш приколах можете зацінити вот в цього приколіста: https://www.youtube.com/@yousuckatprogramming. 

```sh
$ touch test-script
$ echo "#!/bin/bash" > test-scripts    # додаємо шапку комент, яка вказує чим запускати цей файл
$ echo "echo 'Bash script is running!'" >> test-script
$ cat test-script
#!/bin/bash
echo 'Bash script is running!'
$ chmod +x test-script                 # робимо файл виконувальним
$ ./test-script                        # можна запустить скрипт отако просто 
Bash script is running!

$ sh test-script        # можна й отак
Bash script is running!
```

Обидва варіанти запуску скрипта, які були наведені вище, запускають насправді типу віртуальний термінал. В більшості
випадків нам це ок, але якщо ми при цьому хочем змінити якісь глобальні параметри (наприклад `PATH`), то треба використать
`source`:

```sh
$ source test-script     
Bash script is running!
```


Уважний читач, можливо, помітив, що тут якраз той самий `source`, що й використовувався нами під час створення
віртуального середовища для Python.

Хто пропустив: якщо ми хочемо щось прогати на пайтоні, то ми НЕ використовуємо глобальний інтерпретатор. Нам треба
створить в своїй папочці свій:

```sh
$ python3 -m venv venv
$ source venv/bin/activate
(venv) $ which python
./venv/bin/python

(venv) $ deactivate
$ which python
/usr/bin/python         
```


---

Кароче, ви це й так вже мали б знати. Чат жпт в поміч, з терміналом він прям допоможе. 

Удачі. 
